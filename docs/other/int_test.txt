INTEGRATION TESTING APPROACH
=============================

Focus: Test interactions between components using the unittest framework.

1. State Transition Integration Tests
   ├─ Test full state transition flows
   ├─ Verify data passes correctly between states
   ├─ Test state stack operations
   └─ Verify cleanup happens properly

   Example Test (unittest):
   import unittest
   from unittest import mock
   import pygame

   class TestStateTransitions(unittest.TestCase):
       def setUp(self):
           # create_test_application() should build an app with headless pygame and mocks as needed
           self.app = create_test_application()
           self.state_manager = self.app.state_manager

       def test_menu_to_game_list_transition(self):
           # Start in menu
           from states.menu_state import MenuState
           self.assertIsInstance(self.state_manager.current_state, MenuState)

           # Simulate selecting "Browse Games"
           menu_view = self.state_manager.current_state.view
           menu_view.selected_index = 0  # Browse Games

           # Simulate confirm press
           event = pygame.event.Event(pygame.KEYDOWN, key=pygame.K_RETURN)
           self.state_manager.handle_events([event])

           # Should transition to game_list
           from states.game_list_state import GameListState
           self.assertIsInstance(self.state_manager.current_state, GameListState)

           # Game list should be loaded
           self.assertGreaterEqual(len(self.state_manager.current_state.view.games), 0)

2. Download Flow Integration Tests
   ├─ Test complete download and installation
   ├─ Verify game appears in library after download
   ├─ Test progress updates flow correctly
   └─ Test error recovery

   Example Test (unittest):
   import time
   from pathlib import Path
   import unittest
   from unittest import mock

   class TestDownloadFlow(unittest.TestCase):
       @mock.patch('services.network.NetworkService.download_file')
       def test_complete_download_flow(self, mock_download):
           app = create_test_application()
           # Redirect games path to a temp dir if needed
           # e.g., app.hw_config['paths']['games'] = str(tmp_dir)

           def download_side_effect(url, dest, callback=None):
               if callback:
                   callback(1000, 1000)  # 100% complete
               Path(dest).write_bytes(b'test data')
               return True

           mock_download.side_effect = download_side_effect

           game_info = {
               'id': 'test-game',
               'name': 'Test Game',
               'download_url': 'http://test.com/game.zip'
           }

           download_state = app.state_manager.states['download']
           # Implement a start_download method or equivalent action on DownloadState
           download_state.start_download(game_info)

           # Wait briefly for thread (in real tests, better to synchronize)
           time.sleep(0.5)

           game = app.game_library.get_game('test-game')
           self.assertIsNotNone(game)
           self.assertTrue(game.installed)

3. Game Launch Integration Tests
   ├─ Test complete launch sequence
   ├─ Verify input context changes
   ├─ Test pre/post launch commands
   └─ Verify return to game list

   Example Test (unittest):
   import time
   import unittest
   from unittest import mock
   from pathlib import Path
   from models.game import Game

   class TestGameLaunch(unittest.TestCase):
       @mock.patch('subprocess.Popen')
       def test_game_launch_sequence(self, mock_popen):
           # Setup game directory
           with TemporaryDirectory() as d:
               game_dir = Path(d) / "test-game"
               game_dir.mkdir()
               (game_dir / "main.py").write_text("print('game')")

               game = Game(
                   game_id="test-game",
                   name="Test Game",
                   install_path=str(game_dir),
                   entry_point="main.py",
                   installed=True
               )

               # Mock process
               proc = mock.Mock()
               proc.wait.return_value = 0
               mock_popen.return_value = proc

               app = create_test_application()
               app.game_library.add_game(game)

               # Transition to playing state (API may vary)
               app.state_manager.change_state('playing', game=game)

               time.sleep(0.2)
               mock_popen.assert_called_once()
               self.assertEqual(app.input_handler.current_game_id, "test-game")

4. Configuration Persistence Integration Tests
   ├─ Test settings save and load across restarts
   ├─ Test game library persistence
   ├─ Test input mapping persistence
   └─ Verify data integrity

   Example Test (unittest):
   import unittest
   from tempfile import TemporaryDirectory
   from pathlib import Path

   class TestConfigPersistence(unittest.TestCase):
       def test_settings_persistence(self):
           with TemporaryDirectory() as td:
               cfg_path = Path(td) / "config.json"

               app1 = create_test_application()
               app1.config_manager.data_path = cfg_path
               app1.config_manager.set('theme', 'dark')
               app1.config_manager.set('auto_update', True)
               app1.config_manager.save()

               app2 = create_test_application()
               app2.config_manager.data_path = cfg_path
               app2.config_manager.load()

               self.assertEqual(app2.config_manager.get('theme'), 'dark')
               self.assertTrue(app2.config_manager.get('auto_update'))

5. Input System Integration Tests
   ├─ Test input mapping hierarchy in real scenarios
   ├─ Test context switching during game launch
   ├─ Test custom mapping save/load
   └─ Verify all input types work together

   Example Test (unittest):
   import unittest
   from tempfile import TemporaryDirectory
   from pathlib import Path

   class TestInputHierarchy(unittest.TestCase):
       def test_input_hierarchy_in_game_context(self):
           with TemporaryDirectory() as td:
               app = create_test_application()
               app.hw_config['paths']['data'] = td

               # Base mapping
               app.input_handler.mappings = {"confirm": ["BUTTON_A"]}

               # Create per-game override
               game_override_path = Path(td) / "input_overrides" / "games"
               game_override_path.mkdir(parents=True, exist_ok=True)
               (game_override_path / "test-game.json").write_text(
                   '{"confirm": ["BUTTON_B"]}'
               )

               app.input_handler.set_game_context("test-game")
               self.assertIn("BUTTON_B", app.input_handler.mappings["confirm"])

               app.input_handler.clear_game_context()
               self.assertIn("BUTTON_A", app.input_handler.mappings["confirm"])

6. UI Rendering Integration Tests
   ├─ Test complete render pipeline
   ├─ Verify themes apply correctly
   ├─ Test responsive layouts
   └─ Verify no rendering exceptions

   Example Test (unittest):
   import unittest
   import pygame

   class TestRendering(unittest.TestCase):
       def test_render_all_states(self):
           app = create_test_application()
           screen = pygame.Surface((800, 600))

           for state_name in ['menu', 'game_list', 'download', 'settings']:
               app.state_manager.change_state(state_name)
               try:
                   app.state_manager.render(screen)
               except Exception as e:
                   self.fail(f"State {state_name} failed to render: {e}")

7. Error Recovery Integration Tests
   ├─ Test recovery from download failures
   ├─ Test recovery from launch failures
   ├─ Test state transition error recovery
   └─ Verify app remains stable

   Example Test (unittest):
   import unittest
   from unittest import mock
   import time

   class TestErrorRecovery(unittest.TestCase):
       @mock.patch('services.network.NetworkService.download_file')
       def test_download_error_recovery(self, mock_download):
           mock_download.side_effect = ConnectionError("Network error")

           app = create_test_application()
           download_state = app.state_manager.states['download']

           game_info = {'id': 'test', 'name': 'Test', 'download_url': 'http://test'}

           # Should handle error gracefully
           try:
               download_state.start_download(game_info)
               time.sleep(0.2)
           except Exception as e:
               self.fail(f"Download error not handled: {e}")

           self.assertIsNotNone(app.state_manager.current_state)

Integration Test Execution:
# Run integration tests (unittest discovery)
python3 -m unittest discover -s tests/integration -p "test_*.py"

# Run a specific integration test module with verbose output
python3 -m unittest -v tests.integration.test_download_flow
