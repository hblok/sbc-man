10.1 UNIT TEST STRATEGY (FULL)
===============================

UNIT TESTING APPROACH
=====================

Test Framework: pytest

Directory Structure:
tests/
├── unit/
│   ├── test_models.py
│   ├── test_hardware_detection.py
│   ├── test_config_loader.py
│   ├── test_input_handler.py
│   ├── test_file_ops.py
│   └── test_game_library.py
├── integration/
│   ├── test_state_transitions.py
│   ├── test_download_flow.py
│   └── test_game_launch.py
├── fixtures/
│   ├── test_configs/
│   └── test_games/
└── conftest.py

Key Test Categories:

1. Model Tests (test_models.py)
   ├─ Game serialization/deserialization
   ├─ Game.to_dict() produces valid structure
   ├─ Game.from_dict() reconstructs correctly
   ├─ Round-trip: game == Game.from_dict(game.to_dict())
   └─ Handles missing optional fields

   Example Tests:
   def test_game_to_dict():
       game = Game(id="test", name="Test Game", ...)
       data = game.to_dict()
       assert data['id'] == "test"
       assert data['name'] == "Test Game"
       assert 'installed' in data
   
   def test_game_from_dict():
       data = {"id": "test", "name": "Test", ...}
       game = Game.from_dict(data)
       assert game.id == "test"
       assert isinstance(game, Game)
   
   def test_game_round_trip():
       original = Game(id="test", name="Test", ...)
       data = original.to_dict()
       restored = Game.from_dict(data)
       assert original.id == restored.id
       assert original.name == restored.name

2. Hardware Detection Tests
   ├─ Mock file system for device detection
   ├─ Test each device type recognition
   ├─ Test OS type detection
   ├─ Test fallback to defaults
   └─ Test probe failures return safe values

   Example Tests:
   @mock.patch('builtins.open', mock_open(read_data="Anbernic RG353"))
   def test_detect_anbernic_device():
       detector = HardwareDetector()
       device_type = detector._detect_device()
       assert device_type == "anbernic"
   
   @mock.patch('pathlib.Path.exists', return_value=False)
   def test_unknown_device_fallback(mock_exists):
       detector = HardwareDetector()
       device_type = detector._detect_device()
       assert device_type == "desktop"
   
   def test_display_probe_failure():
       with mock.patch('pygame.display.Info', side_effect=Exception):
           prober = HardwareProber()
           result = prober.probe_display()
           assert result['resolution'] == [640, 480]

3. Configuration Loading Tests
   ├─ Test layer merging logic
   ├─ Test each configuration layer loads
   ├─ Test deep merge preserves nested structures
   ├─ Test malformed JSON handling
   ├─ Test missing file handling
   └─ Test validation catches invalid values

   Example Tests:
   def test_config_deep_merge():
       base = {"display": {"resolution": [640, 480], "fullscreen": False}}
       override = {"display": {"fullscreen": True}}
       result = ConfigLoader._deep_merge(base, override)
       assert result['display']['resolution'] == [640, 480]
       assert result['display']['fullscreen'] == True
   
   def test_missing_config_file():
       loader = ConfigLoader("nonexistent", "standard_linux", {})
       config = loader.load_config()
       # Should load default.json only
       assert 'device' in config
       assert 'display' in config
   
   def test_malformed_json_handling():
       with tempfile.NamedTemporaryFile(mode='w', suffix='.json') as f:
           f.write("{invalid json}")
           f.flush()
           # Should handle gracefully
           result = ConfigLoader._load_mapping_file(Path(f.name))
           assert result == {}

4. Input Mapping Tests
   ├─ Test action resolution
   ├─ Test layer hierarchy (higher layers win)
   ├─ Test button name mapping
   ├─ Test keyboard event matching
   ├─ Test joystick event matching
   ├─ Test d-pad event matching
   └─ Test save/load custom mappings

   Example Tests:
   def test_keyboard_action_pressed():
       handler = InputHandler(test_hw_config)
       handler.mappings = {"confirm": ["K_RETURN"]}
       event = pygame.event.Event(pygame.KEYDOWN, key=pygame.K_RETURN)
       assert handler.is_action_pressed("confirm", [event]) == True
   
   def test_button_mapping_hierarchy():
       # Layer 1: default
       # Layer 2: device override
       # Layer 2 should win
       handler = InputHandler(test_hw_config)
       # Simulate hierarchy loading
       assert "BUTTON_1" in handler.mappings["confirm"]
   
   def test_button_name_mapping():
       handler = InputHandler(test_hw_config)
       names = handler._get_button_names(0)
       assert "BUTTON_0" in names
       assert "BUTTON_A" in names
       assert "BUTTON_SOUTH" in names

5. File Operations Tests
   ├─ Test directory creation
   ├─ Test archive extraction (zip, tar.gz)
   ├─ Test free space checking
   ├─ Test permission handling
   └─ Test cleanup on errors

   Example Tests:
   def test_ensure_dir_creates_directory(tmp_path):
       test_dir = tmp_path / "new_dir"
       result = FileOps.ensure_dir(test_dir)
       assert test_dir.exists()
       assert result == test_dir
   
   def test_extract_zip_archive(tmp_path):
       # Create test zip
       zip_path = tmp_path / "test.zip"
       with zipfile.ZipFile(zip_path, 'w') as zf:
           zf.writestr("test.txt", "content")
       
       extract_dir = tmp_path / "extracted"
       FileOps.extract_archive(zip_path, extract_dir)
       assert (extract_dir / "test.txt").exists()
   
   def test_get_free_space(tmp_path):
       space = FileOps.get_free_space(tmp_path)
       assert isinstance(space, int)
       assert space > 0

6. Game Library Tests
   ├─ Test add/remove/get games
   ├─ Test save/load persistence
   ├─ Test search functionality
   ├─ Test filter by installed status
   └─ Test empty library handling

   Example Tests:
   def test_add_game():
       library = GameLibrary(test_hw_config)
       game = Game(id="test", name="Test Game")
       library.add_game(game)
       assert library.get_game("test") == game
   
   def test_remove_game():
       library = GameLibrary(test_hw_config)
       game = Game(id="test", name="Test")
       library.add_game(game)
       library.remove_game("test")
       assert library.get_game("test") is None
   
   def test_library_persistence(tmp_path):
       library = GameLibrary(test_hw_config)
       library.data_path = tmp_path / "games.json"
       game = Game(id="test", name="Test")
       library.add_game(game)
       library.save()
       
       # Load in new instance
       library2 = GameLibrary(test_hw_config)
       library2.data_path = tmp_path / "games.json"
       library2.load()
       assert library2.get_game("test").name == "Test"

7. Network Service Tests
   ├─ Mock HTTP requests
   ├─ Test download with progress
   ├─ Test JSON fetching
   ├─ Test connectivity checks
   └─ Test error handling

   Example Tests:
   @mock.patch('requests.get')
   def test_download_file(mock_get, tmp_path):
       mock_response = mock.Mock()
       mock_response.headers = {'Content-Length': '100'}
       mock_response.iter_content = lambda chunk_size: [b'x' * 100]
       mock_get.return_value = mock_response
       
       dest = tmp_path / "download.bin"
       result = NetworkService.download_file("http://test.com/file", dest)
       assert result == True
       assert dest.exists()
   
   @mock.patch('requests.get')
   def test_fetch_json(mock_get):
       mock_get.return_value.json.return_value = {"key": "value"}
       mock_get.return_value.status_code = 200
       result = NetworkService.fetch_json("http://test.com/api")
       assert result == {"key": "value"}

8. State Tests
   ├─ Test state lifecycle (on_enter/on_exit)
   ├─ Test state-specific logic
   ├─ Test view interactions
   └─ Test error handling in states

   Example Tests:
   def test_menu_state_navigation():
       state = MenuState(mock_state_manager)
       state.on_enter(None)
       initial_index = state.view.selected_index
       # Simulate down press
       state.handle_events([mock_down_event])
       assert state.view.selected_index == initial_index + 1
   
   def test_game_list_state_filter():
       state = GameListState(mock_state_manager)
       state.on_enter(None)
       installed_games = state.view.get_filtered_games(installed=True)
       for game in installed_games:
           assert game.installed == True

9. Download Manager Tests
   ├─ Test observer registration
   ├─ Test progress notifications
   ├─ Test concurrent downloads
   └─ Test error notifications

   Example Tests:
   def test_add_observer():
       manager = DownloadManager()
       observer = mock.Mock()
       manager.add_observer(observer)
       assert observer in manager.observers
   
   def test_notify_progress():
       manager = DownloadManager()
       observer = mock.Mock()
       manager.add_observer(observer)
       manager.notify_progress("dl1", {"percent": 50})
       observer.on_progress_update.assert_called_with("dl1", {"percent": 50})
   
   def test_concurrent_downloads():
       manager = DownloadManager()
       dl1 = manager.start_download(game_info1, dest1)
       dl2 = manager.start_download(game_info2, dest2)
       assert dl1 != dl2
       assert dl1 in manager.downloads
       assert dl2 in manager.downloads

Test Fixtures (conftest.py):
@pytest.fixture
def test_hw_config():
    return {
        "device": {"name": "Test Device", "type": "desktop"},
        "display": {"resolution": [800, 600], "fullscreen": False},
        "paths": {
            "games": "/tmp/games",
            "data": "/tmp/data",
            "config": "/tmp/config",
            "cache": "/tmp/cache"
        },
        "performance": {"target_fps": 60, "vsync": True},
        "launcher": {"python_command": "python3"}
    }

@pytest.fixture
def test_game():
    return Game(
        id="test-game",
        name="Test Game",
        version="1.0.0",
        description="A test game",
        author="Test Author",
        install_path="/tmp/games/test-game",
        entry_point="main.py",
        installed=True
    )

@pytest.fixture
def mock_state_manager():
    manager = mock.Mock(spec=StateManager)
    manager.hw_config = test_hw_config()
    manager.game_library = mock.Mock(spec=GameLibrary)
    manager.config_manager = mock.Mock(spec=ConfigManager)
    manager.input_handler = mock.Mock(spec=InputHandler)
    return manager

Coverage Goals:
├─ Models: 100% (simple data classes)
├─ Core Logic: 90%+ (hardware, config, input)
├─ Services: 85%+ (file ops, network)
├─ States: 75%+ (complex UI interactions)
└─ Overall Target: 85%+

Running Tests:
# All tests
pytest tests/

# Unit tests only
pytest tests/unit/

# With coverage
pytest --cov=src tests/

# Specific test file
pytest tests/unit/test_models.py

# Verbose output
pytest -v tests/
