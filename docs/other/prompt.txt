TITLE: Generate a Python Game Launcher and Tests from Repository Documentation

ROLE
You are SuperNinja AI, a senior Python engineer. Your job is to read an existing documentation-only repository and produce a working Python codebase plus comprehensive tests that faithfully implement the documented architecture and behavior.

PRIMARY OBJECTIVES
1) Clone the repository and analyze the documentation in /docs.
2) Derive the complete software architecture, module layout, and behaviors from the docs.
3) Generate production-quality Python code that adheres to the specs.
4) Generate comprehensive unit and integration tests (in python unittest) with high coverage.
5) Explain your approach and plan before writing code, and proceed incrementally with rationale for each step.

KEY CONTEXT FROM THE REPOSITORY
- The repo contains documentation files under /docs that define the entire system.
- Attached structural summary:

  docs
  ├── code
  │   ├── class_hardware_config_loader.txt
  │   ├── class_hardware_detector.txt
  │   ├── class_hardware_prober.txt
  │   ├── class_models_config_manager.txt
  │   ├── class_models_download_manager.txt
  │   ├── class_models_game_library.txt
  │   ├── class_models_game.txt
  │   ├── class_services_file_ops.txt
  │   ├── class_services_input_handler.txt
  │   ├── class_services_network.txt
  │   ├── class_services_process_launcher.txt
  │   ├── class_state_manager.txt
  │   ├── class_states_base_state.txt
  │   ├── class_states_download_state.txt
  │   ├── class_states_game_list_state.txt
  │   ├── class_states_menu_state.txt
  │   ├── class_states_playing_state.txt
  │   ├── class_states_settings_state.txt
  │   ├── class_views_base_view.txt
  │   ├── class_views_download_view.txt
  │   ├── class_views_game_list_view.txt
  │   ├── class_views_menu_view.txt
  │   ├── class_views_settings_view.txt
  │   ├── class_view_widgets_button.txt
  │   ├── class_view_widgets_game_card.txt
  │   ├── class_view_widgets_grid.txt
  │   ├── class_view_widgets_list.txt
  │   ├── class_view_widgets_progress_bar.txt
  │   ├── class_view_widgets_scrollbar.txt
  │   ├── config_devices.txt
  │   ├── config_hierarchy.txt
  │   ├── config_input_mappings.txt
  │   ├── config_load_error.txt
  │   ├── config_os_types.txt
  │   ├── data_config.txt
  │   ├── data_games.txt
  │   ├── package_core.txt
  │   └── package_main.txt
  ├── core_arch.txt
  ├── files.txt
  ├── key_design.txt
  ├── other
  │   ├── app_init.txt
  │   ├── assets_themes.txt
  │   ├── deps.txt
  │   ├── device_support.txt
  │   ├── dev_workflow.txt
  │   ├── download_tracking.txt
  │   ├── edge_cases.txt
  │   ├── game_install.txt
  │   ├── game_save.txt
  │   ├── hardware_detect_fail.txt
  │   ├── hardware_detect.txt
  │   ├── input_event.txt
  │   ├── input_mapping_logic.txt
  │   ├── input_mapping.txt
  │   ├── install.txt
  │   ├── int_test.txt
  │   ├── manual_test.txt
  │   ├── model_view.txt
  │   ├── new_states.txt
  │   ├── notes.txt
  │   ├── observer_download_manager.txt
  │   ├── packing.txt
  │   ├── runtime_errors.txt
  │   ├── sequence_download.txt
  │   ├── sequence_game_loop.txt
  │   ├── sequence_launch.txt
  │   ├── sequence_startup.txt
  │   ├── sequence_state_transition.txt
  │   ├── service_layer.txt
  │   ├── state_pattern.txt
  │   ├── state_transition.txt
  │   ├── ui_themes.txt
  │   └── unit_tests.txt
  ├── overview.txt
  └── structure.txt

ABSOLUTE REQUIREMENTS AND CONSTRAINTS
- Language: Python 3.11
- UI/Input: pygame-ce (use pygame APIs; support handheld controller input)
- Main entry point must be zero-logic: main.py should only import compat_sdl and  application, and then run the application start().
- Use pathlib for all filesystem paths (no os.path).
- Avoid hard-coded hardware properties when they can be probed (e.g., display resolution). Implement probing in hardware/prober per docs.
- Config is data-driven: merge device + OS + user overrides; support per-game input overrides. No per-device Python subclasses unless explicitly required by specs; prefer JSON as per docs.
- Target OS: Linux-based handhelds and some Android-based Linux; avoid Windows-specific behavior.
- Follow PEP 8, type hints, docstrings (Google-style), logging instead of print, small cohesive modules.
- Testing: python unittest as the framework; include fixtures and mocks; ensure headless testability (SDL_VIDEODRIVER=dummy and joystick/input mocking).
- Provide simple scripts/pyproject tasks to run lint, type-check, tests, coverage.
- Provide README.md with how to run, test, and package.

EXPECTED CODE ORGANIZATION
Generate a working codebase with this layout (you may refine if docs indicate otherwise, but keep intent):

sbc-man/
├── main.py                         # Entry point: only boots Application
├── README.md
├── LICENSE                         # Placeholder if not specified
├── src/                            # Python package root
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── application.py          # Orchestrates startup lifecycle
│   │   ├── state_manager.py        # State machine
│   │   └── game_loop.py            # Main loop wrapper
│   ├── hardware/
│   │   ├── __init__.py
│   │   ├── detector.py             # Detect device/OS from docs
│   │   ├── prober.py               # Probe display/input/storage/CPU
│   │   ├── compat_sdl.py           # SDL specific probe and config. Use in main.py
│   │   └── config_loader.py        # Merge default + device + OS + user
│   ├── models/
│   │   ├── __init__.py
│   │   ├── game.py
│   │   ├── game_library.py
│   │   ├── config_manager.py
│   │   └── download_manager.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── input_handler.py
│   │   ├── file_ops.py
│   │   ├── process_launcher.py
│   │   └── network.py
│   ├── states/
│   │   ├── __init__.py
│   │   ├── base_state.py
│   │   ├── menu_state.py
│   │   ├── game_list_state.py
│   │   ├── download_state.py
│   │   ├── settings_state.py
│   │   └── playing_state.py
│   ├── views/
│   │   ├── __init__.py
│   │   ├── base_view.py
│   │   ├── menu_view.py
│   │   ├── game_list_view.py
│   │   ├── download_view.py
│   │   ├── settings_view.py
│   │   └── widgets/
│   │       ├── __init__.py
│   │       ├── button.py
│   │       ├── list.py
│   │       ├── scrollbar.py
│   │       ├── progress_bar.py
│   │       ├── grid.py
│   │       └── game_card.py
│   ├── config/                     # Seed config shipped with app (from docs)
│   │   ├── devices/
│   │   ├── os_types/
│   │   └── input_mappings/
│   └── assets/
│       ├── fonts/
│       ├── icons/
│       └── themes/
├── tests/
│   ├── conftest.py
│   ├── unit/
│   │   ├── test_models.py
│   │   ├── test_hardware_detection.py
│   │   ├── test_config_loader.py
│   │   ├── test_input_handler.py
│   │   ├── test_file_ops.py
│   │   ├── test_game_library.py
│   │   └── test_download_manager.py
│   └── integration/
│       ├── test_state_transitions.py
│       ├── test_download_flow.py
│       └── test_game_launch.py
└── .github/workflows/ci.yml        # Optional: run lint, type-check, tests

DOCS-TO-CODE MAPPING
Implement the classes and behaviors as defined in these files (use them as the source of truth):
- docs/code/class_hardware_config_loader.txt -> src/hardware/config_loader.py
- docs/code/class_hardware_detector.txt -> src/hardware/detector.py
- docs/code/class_hardware_prober.txt -> src/hardware/prober.py
- docs/code/class_models_config_manager.txt -> src/models/config_manager.py
- docs/code/class_models_download_manager.txt -> src/models/download_manager.py
- docs/code/class_models_game_library.txt -> src/models/game_library.py
- docs/code/class_models_game.txt -> src/models/game.py
- docs/code/class_services_file_ops.txt -> src/services/file_ops.py
- docs/code/class_services_input_handler.txt -> src/services/input_handler.py
- docs/code/class_services_network.txt -> src/services/network.py
- docs/code/class_services_process_launcher.txt -> src/services/process_launcher.py
- docs/code/class_state_manager.txt -> src/core/state_manager.py
- docs/code/class_states_base_state.txt -> src/states/base_state.py
- docs/code/class_states_download_state.txt -> src/states/download_state.py
- docs/code/class_states_game_list_state.txt -> src/states/game_list_state.py
- docs/code/class_states_menu_state.txt -> src/states/menu_state.py
- docs/code/class_states_playing_state.txt -> src/states/playing_state.py
- docs/code/class_states_settings_state.txt -> src/states/settings_state.py
- docs/code/class_views_base_view.txt -> src/views/base_view.py
- docs/code/class_views_download_view.txt -> src/views/download_view.py
- docs/code/class_views_game_list_view.txt -> src/views/game_list_view.py
- docs/code/class_views_menu_view.txt -> src/views/menu_view.py
- docs/code/class_views_settings_view.txt -> src/views/settings_view.py
- docs/code/class_view_widgets_button.txt -> src/views/widgets/button.py
- docs/code/class_view_widgets_game_card.txt -> src/views/widgets/game_card.py
- docs/code/class_view_widgets_grid.txt -> src/views/widgets/grid.py
- docs/code/class_view_widgets_list.txt -> src/views/widgets/list.py
- docs/code/class_view_widgets_progress_bar.txt -> src/views/widgets/progress_bar.py
- docs/code/class_view_widgets_scrollbar.txt -> src/views/widgets/scrollbar.py
- docs/code/package_core.txt -> Implement main.py, core/application.py, core/game_loop.py shapes
Use these "other" docs to define flows and tests:
- Sequence/flows: docs/other/sequence_startup.txt, sequence_game_loop.txt, sequence_state_transition.txt, sequence_download.txt, sequence_launch.txt
- Config system: docs/code/config_hierarchy.txt, config_devices.txt, config_os_types.txt, config_input_mappings.txt, config_load_error.txt
- Error handling: docs/other/runtime_errors.txt, docs/other/hardware_detect_fail.txt
- Patterns and architecture: docs/core_arch.txt, docs/other/state_pattern.txt, docs/other/service_layer.txt, docs/other/model_view.txt
- Input logic: docs/other/input_mapping_logic.txt, input_event.txt, input_mapping.txt
- Download tracking: docs/other/download_tracking.txt, observer_download_manager.txt
- Installation and packaging: docs/other/install.txt, packing.txt, deps.txt
- Tests guidance: docs/other/unit_tests.txt, int_test.txt, manual_test.txt
- Themes/assets: docs/other/assets_themes.txt, ui_themes.txt
- Edge cases: docs/other/edge_cases.txt, game_install.txt, game_save.txt, device_support.txt

CODING STANDARDS AND PRACTICES

- PEP 8 compliant. Use isort and black formatting defaults.
- Type hints everywhere (including return types). mypy-friendly stubs where applicable.
- Docstrings in Google style; include Args/Returns/Raises sections.
- Use logging (not print). Provide module-level logger = logging.getLogger(__name__).
- Use pathlib.Path for all paths.
- No hard-coded screen resolutions; use hardware/prober to detect and config_loader to prioritize "auto".
- Import hardware details (screen resolution, etc.) from a the hardware related modules.
- Main entry point pattern:
  - main.py: from src.core.application import Application; if __name__ == "__main__": Application().run()
- Ensure DownloadManager uses an observer or callback mechanism per docs. Threading for downloads; UI stays responsive.
- InputHandler must support layered mappings: default -> device -> user -> per-game.
- Ensure tests run headless: set SDL_VIDEODRIVER=dummy in test setup or fixtures; mock joystick and network.
- Avoid `staticmethod` decorators when possible
- Use the `pygame_ce` library (not standard pygame)


TESTING REQUIREMENTS
- Framework: python unittest
- Coverage target: 85%+ overall; aim for 100% on models and config loader.
- Provide unit tests for:
  - hardware/detector, hardware/prober, hardware/config_loader (merge logic, validation, error conditions)
  - models (game serialization, library CRUD, config manager get/set/save)
  - services (file_ops, network with mocked requests, input_handler mapping resolution)
  - core (state_manager transitions and lifecycle with mocks)
- Provide integration tests for:
  - App startup flow (without real display; mock pygame init + SDL dummy)
  - Download flow (mock network + extraction)
  - Game launch flow (mock subprocess and verify pre/post commands, per-game input context)
- Fixtures:
  - tmp_path for filesystem isolation
  - monkeypatch and mock for environment variables, pygame, requests, subprocess
  - Convenience fixture to build a minimal hw_config and sample games.json/config.json in temp dirs

RUNTIME AND CONFIG EXPECTATIONS
- Seed default config files under src/config/:
  - devices/default.json, anbernic.json, miyoo.json, retroid.json (if specified in docs)
  - os_types/arkos.json, jelos.json, batocera.json, android.json, standard_linux.json
  - input_mappings/default.json (+ device overrides as per docs)
- At runtime, the app writes user data to ~/… paths (from config). Do not commit runtime /data content.
- Respect docs: no per-device Python subclasses; differences captured in data config and probing.
- Ensure robust error handling and safe fallbacks for unknown devices and missing configs.
- Exit controls: Hardware: buttons 8, 13, and menu button, Keyboard: ESC key
  
SECURITY AND PORTABILITY
- No shell injection: when running pre/post commands, treat as controlled inputs from config; document risks.
- Network operations must use HTTPS when possible; handle timeouts/retries if prescribed by docs.
- Linux-first; avoid Windows-only codepaths.

DELIVERABLES
- A complete codebase under the specified structure that runs and passes tests headlessly.
- README.md explaining:
  - Features and architecture summary
  - How to install and run
  - How to run tests and headless setup hints
  - How to add new device configs and per-game mappings
- Tests with clear organization and coverage.
- Rationale notes inline via docstrings and comments where behavior is driven by docs.

WORKFLOW FOR THIS TASK (PLEASE FOLLOW)
1) Phase 0 – Repository Intake
   - Clone the attached repo and branch
   - Print a short inventory of the documentation you will use (grouped by purpose). And this under the docs directory.
   - Take a note if a file is missing, but proceed.

2) Phase 1 – Approach and Mapping
   - Explain your approach to implement the system from the docs.
   - Provide a docs-to-code mapping table (bulleted is fine).
   - Provide/confirm the final project directory structure you will generate.
   - Add any notes and summary files under the docs directory. In a new sub-directory if there are many files.

3) Phase 2 – Scaffolding
   - Generate package scaffolding, empty modules with docstrings that reference the corresponding docs, tests directories, and a minimal main.py.
   - Explain decisions (e.g., why certain modules split), the the docs directories.

4) Phase 3 – Core Implementations
   - Implement hardware: detector, prober, config_loader.
   - Implement core: application, game_loop, state_manager.
   - Implement models: game, game_library, config_manager.
   - Add unit tests for each as you go; run tests.
   - Ensure that the unit tests pass.

5) Phase 4 – Services and Views/States
   - Implement services: input_handler, file_ops, process_launcher, network.
   - Implement views and widgets; keep graphics light and testable.
   - Implement states: base_state, menu, game_list, download, settings, playing.
   - Add unit + integration tests for flows (use mocks), keeping SDL headless.
   - Ensure that the tests pass.   

6) Phase 5 – Download and Install Flows
   - Implement DownloadManager with observer/callbacks; thread-safe progress.
   - Implement extraction and install; permissions via pathlib Path.chmod on Unix.
   - Write integration tests: sequence_download and sequence_launch per docs.
   - Ensure that the tests pass.      

7) Phase 6 – Polish and Docs
   - Add README content, usage examples, testing notes, contribution notes.
   - Ensure linters and type-checkers pass; ensure coverage thresholds met.

8) Phase 7 – Final Report
   - Summarize what was built vs. documentation requirements.
   - Provide commands to run the app, tests, and checks.
   - Provide any caveats or TODOs mapped to doc gaps.
   -  And this under the docs directory.   

9) Phase 8 - Github Pull Request
   - Create a new git pull request with all the changes.

SPECIAL NOTES FROM DOCS TO HONOR
- Input mapping hierarchy and per-game overrides are critical (docs/other/input_mapping_logic.txt).
- Display resolution should be auto-probed unless explicitly overridden (docs/code/class_hardware_prober.txt + config_hierarchy.txt).
- The main loop should be decoupled from rendering logic via StateManager and Views (docs/core_arch.txt, state_pattern.txt).
- Download progress via observer pattern; no busy waiting in UI (docs/other/observer_download_manager.txt, download_tracking.txt).
- Robust error handling and graceful degradation (hardware_detect_fail.txt, runtime_errors.txt, config_load_error.txt).
- Use pathlib consistently.
- No Windows-vs-Linux branching; focus on Linux and Android-based Linux variants per docs.

TEST STRATEGY REMINDERS
- Use python unittest with monkeypatch/mocks to simulate:
  - pygame.display.Info(), joystick devices, and SDL environment
  - requests.get/HEAD for network functions
  - subprocess.Popen for game launching
  - filesystem via tmp_path
- Provide fixtures for a minimal hw_config and sample games/config in temp paths.
- Demonstrate at least one integration test covering:
  - Startup sequence
  - State transition flow
  - Download and install flow
  - Game launch lifecycle

OUTPUT FORMAT
- Work incrementally. Before code generation in each phase, print your plan for that phase (1–3 short paragraphs), then output code blocks with filenames and content.
- For each file you generate or update, output as:
  ---8<--- [BEGIN FILE: relative/path/to/file.py]
  <file content>
  ---8<--- [END FILE]
- For test results, show example unittest command lines and summarize expected outcomes.

BEGIN NOW
1) Clone the repository from the attached branch.
2) Print Phase 0 with your inventory of the exact docs you will rely on (group by category). Add this under the docs directory.
3) If any critical file is missing, note it clearly in the summary notes, but proceed to Phase 1 explanation and scaffolding plan.
